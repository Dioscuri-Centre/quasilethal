/*******************************************************************************
   This code simulates the stochastic quasispecies model with multiple viable 
	 and one non-viable genotypes. It generates a series of random fitness 
	 landscapes and simulates the model with and without lethal mutations on each
	 landscape. It outputs the time to best adapted genotype and a sequence of
	 genotypes taken by evolution (evolutionary trajectory).
   
   Please cite the following article when publishing data generated by this code
   
   Evolutionary adaptation is facilitated by the presence of lethal genotypes, 
	 Viktoria Blavatska, Bartlomiej Waclaw, arXiv:2301.07599 [q-bio.PE]

   Contributing author:
   Dr Bartlomiej Waclaw, IChF PAN, bwaclaw@ichf.edu.pl

   Copyright (2022) Bartlomiej Waclaw, IChF PAN.


    This is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The software is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
    See the GNU General Public License for more details.

    A copy of the GNU General Public License can be found in the file 
    License.txt or at <http://www.gnu.org/licenses/>.
*******************************************************************************/

/*
	The code has been tested with GNU Compiler (ver. 4.9.2 or above).
	To compile it, please use
	
	g++ directed_evolution_trajectories_both_models.cpp -w -O3 -o evolution.exe
	
	then run the executable "evolution.exe" (no command-line parameters required).
	
	All parameters are set in the "Parameters" section of the code below.
	Changing any of the parameters requires the code to be re-compiled.
	
	As is, the program will generate data for mu=0.04 and gamma=0.76,
	for 1000 fitness landscapes, and 20 replicate simulations on each landscape.

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <vector>
#include <iostream>
#include <fstream>
using namespace std;

// -------------------PARAMETERS------------------------------

const int L=7 ; // binary sequence length. Total genotype space size will be 2^L + 1 for the lethal genotype
const int K=1000 ; // carrying capacity (affects the rate of death, the birth rate is not affected)
float mu=0.04 ; // mutation probability to create a viable genotype
float mu_lethal0=mu*19 ; // probability that a lethal genotype is generated
const int FLrepetitions=100 ; // how many fitness landscapes to simulate
const int Nrepetitions=20 ; // how many runs per fitness landscapes to simulate
char name[]="model_comparison_L7_K=1000_mu=004_mulet=0_and_19mu.txt" ; // name of the output file with times to best-adapted genotype
#define VERBOSE // if defined, display some info every few steps
#define SAVE_FL

// ----------------END OF PARAMETERS---------------------------

// --------- random number generator---------------
static long long unsigned int _x=0x000100010001LL, _mul=0x0005deece66dLL, _add=0xbLL ;
double _drand48(void)  // works only on compilers with long long int!
{
  _x=_mul*_x+_add ; _x&=0xffffffffffffLL ;
  return (_x/281474976710656.0) ;
}

void _srand48(int a) { _x=a ; }

static long long unsigned int _x2=0x000100010001LL ;
double _drand48v2(void)  // works only on compilers with long long int!
{
  _x2=_mul*_x2+_add ; _x2&=0xffffffffffffLL ;
  return (_x2/281474976710656.0) ;
}

void _srand48v2(int a) { _x2=a ; }


void err(const char *reason)
{
  cout <<reason<<endl ; 
#ifdef __WIN32
  system("pause") ;
#endif  
  exit(0) ;
}

void err(const char *reason, int a)
{
  cout <<reason<<": "<<a<<endl ; 
#ifdef __WIN32
  system("pause") ;
#endif    
  exit(0) ;
}

void err(const char *reason, char *a)
{
  cout <<reason<<": "<<a<<endl ; 
#ifdef __WIN32
  system("pause") ;
#endif    
  exit(0) ;
}

void err(const char *reason, double a)
{
  cout <<reason<<": "<<a<<endl ; 
#ifdef __WIN32
  system("pause") ;
#endif    
  exit(0) ;
}

// ------------global variables--------------------

// here we define new types of variables using build-in types. This is to make debugging easier
typedef unsigned int Genotype ;
typedef float Fitness ;
typedef unsigned int Number ;

struct Organism {
	Genotype g ;
	vector<Genotype> gvis ; // visited genotypes
};

class Average {
	public:
		long long int n ;
		double sum ;
		Average() { n=0 ; sum=0 ; }
    Average& operator+=(double value) {
    		n++ ; sum+=value ;
        return *this; 
    }		
    double mean() { 
			if (n>0) return sum/(1.*n) ; else return 0. ;
		}
};

int N ; // number of non-lethal genotypes (will be calculated later)
Fitness *f ; // fitnesses (growth rates) of genotypes; f[g] for g=0...N
Organism *o ; // organisms o[i] for i=0...K-1
Number *n ; // no. of organisms of each genotype; n[g] for g=0...N
int ntot ; // number of organisms in the system

// ----------helper functions----------------------

inline Genotype mutate(Genotype g) // only for non-lethal mutations
{
  return g^(1<<int(_drand48()*L)) ; // this toggles a randomly selected bit of g
}

// i=0...2^L-1 are viable genotypes
// i=2^L is the lethal genotype

void save_fitness_landscape() 
{
/*	This procedure saves the fitness landscape as a sequence of floating point 
		numbers representing fitnesses of genototypes 0...2^L - 1
*/
	char txt[256] ;
	sprintf(txt,"FL_%s",name) ;
	ofstream fl(txt,ios::app) ;
	for (int i=0;i<N;i++) fl<<f[i]<<" " ; fl<<endl ;
	fl.close() ;
}



void generate_fitness_landscape(int seed) // the seed is used to create a series of fitness landscapes identical no matter how the stochastic process behaves
{
	int i,j;
	_srand48v2(seed) ; for (i=0;i<100;i++) _drand48v2() ; // random seed and randomization of the RNG

	f[0]=0.5 ; 
	float fmax=f[0] ;
	for (i=1;i<N-1;i++) {
		f[i]=_drand48v2() ;
		if (f[i]>fmax) { fmax=f[i] ; j=i ; }
	}
	f[N-1]=1 ; // best-adapted genotype	
}


double tot_rate()
{
	double r=0 ;
	for (int i=0;i<N;i++) r+=n[i]*f[i] ; // replication
	r+=(1.*ntot/K)*ntot ; // death
	return r ;
}

int last_index ;
double run_directed_evolution(float mu_lethal)
{
	if (mu+mu_lethal>1) err("mu+mu_lethal>1") ;
	int i,j;
	// initial condition
	for (i=0;i<N;i++) n[i]=0 ;
	n[0]=K ; ntot=K ; 
	for (i=0;i<2*K;i++) {
		o[i].g=0 ;
		o[i].gvis.clear() ;
		o[i].gvis.push_back(0) ;
	}
	double tt=0 ;
	last_index=-1 ;
	double rr=tot_rate() ;

	/* Here is what the code simulates:
		A_i --> A_i + A_j  w.r. f_i  (j decided later based on mu, mu_lethal)
		A_i --> 0   w.r. N/K
		
		per-capita birth rate never exceeds 1
		per-death death rate can exceed 1 but is rarely larger than that
	*/

	// actual simulation	
	unsigned long long int steps=0 ;
	do {
		if (ntot>=2*K) err("ntot too large!") ; // this should never occur
		double x; 
		do {
			i=int(_drand48()*ntot) ; // random organism is selected
			x=_drand48()*3 ; //this must be always larger than the total per-capita rate
		} while (x>f[o[i].g]+1.*ntot/K) ; // selection done with prob. proportional to birth+death rates
		if (x<1.*ntot/K) { // death
			n[o[i].g]-- ; rr-=f[o[i].g]+(2.*ntot-1)/K ;
			ntot-- ;
			o[i]=o[ntot] ;
		} else {	// reproduction
			x=_drand48() ;
			j=ntot ;
			#ifdef SAVE_REP_RATES
				av_rate[o[i].g]+=f[o[i].g]-1.*ntot/K ;
			#endif
			if (x<mu) {
				o[j].g=mutate(o[i].g) ;  // mutation with prob. mu. ONLY ONE offspring mutates
				o[j].gvis=o[i].gvis ; 
				o[j].gvis.push_back(o[j].g) ;
			}
			else if (x<mu+mu_lethal) { // lethal genotype
				// no new organism produced in this case
				goto e1 ;
			} else o[j]=o[i] ;  
			ntot++ ;
			n[o[j].g]++ ; rr+=f[o[j].g]+(2.*ntot-1)/K ;
			if (o[j].g==N-1) last_index=j ;
		}
e1:
		#ifdef VERBOSE
		if (steps%10000000==0) {
			int nmax=0,ni=-1 ;
			for (i=0;i<N;i++) if (n[i]>nmax) { nmax=n[i] ; ni=i ; }
			cout<<steps/K<<" ntot="<<ntot<<" imax="<<ni<<" n="<<nmax<<"\t"<<flush ; 
		}
		#endif
		tt+=1./rr ; 
		steps++ ;
		if (steps%(2*K)) {
			rr=tot_rate() ; // re-evaluate the rate to prevent accumulation of round-off errors
		}
	} while (n[N-1]==0 && ntot>0) ; // exit if the fittest genotype has been found or the population died out
	if (ntot==0) tt=1e16 ;
	cout<<steps/K<<" ntot="<<ntot<<endl ;
	return tt ;
}

//-------------------main procedure - entry point of the program--------------------------

int main()
{
	cout<<"mut. prob="<<mu<<endl ;
  int i,j ;
	_srand48(1221) ; for (i=0;i<100;i++) _drand48() ; // random seed and randomization of the RNG

	N=1<<L ; // no. of genotypes
	f=new Fitness[N+1] ; n=new Number[N+1] ; o=new Organism[2*K] ; // allocate memory for data structures
	
	ofstream data(name) ; data.close() ; // opens an empty file to save adaptation times and trajectories
	/* the file is made of a rows of numbers in text format, each row contains the following numbers separated by tabs:
		
		index of the current fitness landscape [0..FLrepetitions-1]
		index of the current run  [0..Nrepetitions-1]
		type of run (0 = no lethal genotype, 1 = lethal genotype simulated)
		time to reach the best-adapted genotype
		a sequence of genotype indices representing the evolutionary trajectory
		
	*/
	char txt[256] ;
	#ifdef SAVE_FL
		sprintf(txt,"FL_%s",name) ;
		ofstream fl(txt) ; fl.close() ; // open an empty file to save fitness landscapes. Each row = separate landscape
	#endif

	for (int rep=0;rep<FLrepetitions;rep++) {
		#ifdef RAND_SEED
			generate_fitness_landscape(RAND_SEED) ;
		#else
			generate_fitness_landscape(rep) ;
		#endif
		#ifdef SAVE_FL
			save_fitness_landscape() ;
		#endif

  	ofstream data(name,ios::app) ; 
		
		cout<<"no_lethal:"<<endl ;
		for (int nrun=0;nrun<Nrepetitions;nrun++) {
			double tt=run_directed_evolution(0) ;
	  	cout <<"rep="<<rep<<" time to best-adapted genotype = "<<tt<<endl ;		
			data<<rep<<" "<<nrun<<" 0\t"<<tt ;
	  	for (i=0;i<o[last_index].gvis.size();i++) data<<" "<<o[last_index].gvis[i] ; 
			data<<endl ; 
	
			cout<<"lethal:"<<endl ;
			tt=run_directed_evolution(mu_lethal0) ;
	  	cout <<"rep="<<rep<<" time to best-adapted genotype = "<<tt<<endl ;		
			data<<rep<<" "<<nrun<<" 1\t"<<tt ;
	  	for (i=0;i<o[last_index].gvis.size();i++) data<<" "<<o[last_index].gvis[i] ; 
			data<<endl ; 
		}
		
		data.close() ; // append a new line of data to the existing file
  }
}

